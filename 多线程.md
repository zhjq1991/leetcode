# 线程
-------------------------------------------
## 1.1 线程标识

+ 线程ID使用`pthread_t`类型来表示的
+ 
```C++
  // 比较两个线程ID
  #include <pthread.h>

  int pthread_equal (pthread_t tid1, pthread_t tid2);

    返回值：若相等，返回非0数值；否则，返回0
  ```

+ 线程可以通过调用 `pthread_self` 函数获得自身的线程ID。
 ```C++
#include <pthread.h>

pthread_t pthread_self (void);

返回值：调用线程的线程 ID
 ```
--------------------------------------------
## 1.2 线程创建

 ```C++
#include <pthread.h>

int pthread_create (pthread_t *restrict tidp,
                    const pthread_attr_t *restrict attr,
                    void *(*start_rtn)(void *), void *restrict arg);
                    返回值：若成功，返回0； 否则，返回错误编号
```
--------------------------------------------
## 1.3 线程终止
+ 如果进程中的任意线程调用了 `exit`、`_Exit` 或者 `_exit`，那么整个进程就会终止。
+ 单个线程可以通过3种方式推出，因此可以在不终止整个进程的情况下，停止它的控制流。
  
  > 1. 线程可以简单地从启动历程中返回，返回值是线程的退出码。
  > 2. 线程可以被同一进程中的其他线程取消。
  > 3. 线程调用 `pthread_exit`。

```C++
#include <pthread.h>

void pthread_exit (void *rval_ptr);
```

```C++
#include <pthread.h>

int pthread_join (pthread_t thread, void **rval_ptr);
```
+ 如果线程简单地从它的启动例程返回，`rval_ptr` 就包含返回码。如果线程被取消，有 `rval_ptr` 指定的内存单元就设置为 `PTHREAD_CANCELED` 。
+ 如果对线程的返回值并不感兴趣，那么可以把 `rval_ptr` 设置为 `NULL`。在这种情况下，调用 `pthread_join` 函数可以等待指定的线程终止，但并不获取线程的终止状态。
+ 线程可以通过调用 `pthread_cancel` 函数来请求取消同一进程中的其他线程。
  ```C++
  #include <pthread.h>

  int pthread_cancel (pthread_t pid);

            返回值： 若成功，返回0； 否则，返回错误编号
  ```

|进程原语|线程原语|描述|
|:---:|:---:|:---:|
|fork|pthread_create|创建新的控制流|
|exit|pthread_exit|从现有的控制流中退出|
|waitpid|pthread_join|从控制流中得到退出状态|
|atexit|pthread_cancel_push|注册在退出控制流时调用的函数|
|getpid|pthread_self|获取控制流的ID|
|abort|pthread_cancel|请求控制流的非正常退出|

+ 可以调用 `pthread_detach` 分离线程
```C++
#include <pthread.h>

int pthread_detach (pthread_t tid);

        返回值：若成功，返回0； 否则，返回错误编码
```
------------------------------------

## 1.4 线程同步
### 1.4.1 互斥量

+ 