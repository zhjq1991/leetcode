# 线程
-------------------------------------------
## 1.1 线程标识

+ 线程ID使用`pthread_t`类型来表示的
+ 
```C++
  // 比较两个线程ID
  #include <pthread.h>

  int pthread_equal (pthread_t tid1, pthread_t tid2);

    返回值：若相等，返回非0数值；否则，返回0
  ```

+ 线程可以通过调用 `pthread_self` 函数获得自身的线程ID。
 ```C++
#include <pthread.h>

pthread_t pthread_self (void);

返回值：调用线程的线程 ID
 ```
--------------------------------------------
## 1.2 线程创建

 ```C++
#include <pthread.h>

int pthread_create (pthread_t *restrict tidp,
                    const pthread_attr_t *restrict attr,
                    void *(*start_rtn)(void *), void *restrict arg);
                    返回值：若成功，返回0； 否则，返回错误编号
```
--------------------------------------------
## 1.3 线程终止
+ 如果进程中的任意线程调用了 `exit`、`_Exit` 或者 `_exit`，那么整个进程就会终止。
+ 单个线程可以通过3种方式推出，因此可以在不终止整个进程的情况下，停止它的控制流。
  
  > 1. 线程可以简单地从启动历程中返回，返回值是线程的退出码。
  > 2. 线程可以被同一进程中的其他线程取消。
  > 3. 线程调用 `pthread_exit`。

```C++
#include <pthread.h>

void pthread_exit (void *rval_ptr);
```

```C++
#include <pthread.h>

int pthread_join (pthread_t thread, void **rval_ptr);
```
+ 如果线程简单地从它的启动例程返回，`rval_ptr` 就包含返回码。如果线程被取消，有 `rval_ptr` 指定的内存单元就设置为 `PTHREAD_CANCELED` 。
+ 如果对线程的返回值并不感兴趣，那么可以把 `rval_ptr` 设置为 `NULL`。在这种情况下，调用 `pthread_join` 函数可以等待指定的线程终止，但并不获取线程的终止状态。
+ 线程可以通过调用 `pthread_cancel` 函数来请求取消同一进程中的其他线程。
  ```C++
  #include <pthread.h>

  int pthread_cancel (pthread_t pid);

            返回值： 若成功，返回0； 否则，返回错误编号
  ```

|进程原语|线程原语|描述|
|:---:|:---:|:---:|
|fork|pthread_create|创建新的控制流|
|exit|pthread_exit|从现有的控制流中退出|
|waitpid|pthread_join|从控制流中得到退出状态|
|atexit|pthread_cancel_push|注册在退出控制流时调用的函数|
|getpid|pthread_self|获取控制流的ID|
|abort|pthread_cancel|请求控制流的非正常退出|

+ 可以调用 `pthread_detach` 分离线程
```C++
#include <pthread.h>

int pthread_detach (pthread_t tid);

        返回值：若成功，返回0； 否则，返回错误编码
```
------------------------------------

## 1.4 线程同步
### 1.4.1 互斥量

+ 互斥变量是用 `pthread_mutex_t` 数据类型表示的。在使用互斥量以前，必须首先对它进行初始化，可以把它设置为常量 `PTHREAD_MUTEX_INITIALIZER（只适用于静态分配的互斥量），也可以通过调用 `pthread_mutex_init` 函数进行初始化。
```C++
#include <pthread.h>

int pthread_mutex_init (pthread_mutex_t *restrict mutex,
                        const pthread_mutexattr_t *restrict attr);

int pthread_mutex_destroy (pthread_mutex_t *mutex);

          两个函数的返回值：若成功，返回0；否则，返回错误编号
```
+ 对互斥量进行加锁，需要调用 `pthread_mutex_lock`。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。
```C++
#include <pthread.h>

int pthread_mutex_lock (pthread_mutex_t *mutex);

int pthread_mutex_trylock (pthread_mutex_t *mutex);

int pthread_mutex_unlock (pthread_mutex_t *mutex);
        所有函数的返回值：若成功，返回0；否则，返回错误编号
```

### 1.4.2 避免死锁

+ 可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量。

### 1.4.3 函数 `pthread_mutex_timedlock`

+ 当线程试图获取一个已加锁的互斥量时，`pthread_mutex_timedlock` 互斥量原语允许绑定线程阻塞时间。
+ `pthread_mutex_timedlock` 函数与 `pthread_mutex_lock` 是基本等价的，但是在达到超时时间值时，`pthread_mutex_timedlock`不会对互斥量进行加锁，而是返回错误码 `ETIMEDOUT`。
  ```C++
  #include <pthread.h>
  #include <time.h>

  int pthread_mutex_timedlock (pthread_mutex_t *restrict mutex,
                               const struct timespec *restrict tsptr);
  ```
  
### 1.4.4 读写锁

```C++
#include <pthread.h>

int pthread_rwlock_init (pthread_rwlock_t *restrict rwlock,
                         const pthread_rwlockattr_t *restrict attr);

int pthread_rwlock_destroy (pthread_rwlock_t *rwlock);
```

+ 要在读模式下锁定读写锁，需要调用 `pthread_rwlock_rdlock`。要在写模式下锁定读写锁，需要调用 `pthread_rwlock_wrlock`。不管以何种方式锁住读写锁，都可以调用`pthread_rwlock_unlock`进行解锁。
  ```C++
  #include <pthread.h>

  int pthread_rwlock_rdlock (pthread_rwlock_t *rwlock);

  int pthread_rwlock_wrlock (pthread_rwlock_t *rwlock);

  int pthread_rwlock_unlock (pthread_rwlock_t *rwlock);

  int pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock);

  int pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock);
  
      返回值：若成功，返回0；否则，返回错误编号
  ```

### 1.4.5 带有超时的读写锁

```C++
#include <pthread.h>
#include <time.h>

int pthread_rwlock_timedrdlock (pthread_rwlock_t *restrict rwlock,
                                const struct timespec *restrict tsptr);

int pthread_rwlock_timedwrlock (pthread_rwlock_t *restrict rwlock,
                                const struct timespec *restrict tsptr);
```

### 1.4.6 条件变量

+ 条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。
+ 条件本身是由互斥量保护的。线程在改变条件之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。
+ 在使用条件变量之前，必须先对它进行初始化。有 `pthread_cond_t` 数据类型表示的条件变量可以用两种方式进行初始化，可以把常量 **`PTHREAD_COND_INITIALIZER`** 赋给静态分配的条件变量，但是如果条件变量是动态分配的，则需要使用 **`pthread_cond_init`**函数对它进行初始化。

```C++
#include <pthread.h>

int pthread_cond_init (pthread_cond_t *restrict cond,
                       const pthread_condattr_t *restrict attr);

int pthread_cond_destroy (pthread_cond_t *cond);

        两个函数的返回值：若成功，返回0；否则，返回错误编号
```

+ 我们使用 `pthread_cond_wait` 等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。

```C++
#include <pthread.h>

int pthread_cond_wait (pthread_cond_t *restrict cond,
                       pthread_mutex_t *restrict mutex);

int pthread_cond_timedwait (pthread_cond_t *restrict cond,
                            pthread_mutex_t *restrict mutex,
                            const struct timespec *restrict tsptr);

int pthread_cond_signal (pthread_cond_t *cond);

int pthread_cond_broadcast (pthread_cond_t *cond);
```
------------------------------------

# 线程控制

## 1.1 线程限制

